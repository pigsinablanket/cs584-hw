\subsection*{Solution}

\subsubsection*{Pseudocode}
\begin{verbatim}
genSubArray(xs, start, end, subarray):
  if end = len(xs):
    return subarray

  if start > end:
    return genSubArray(xs, 0, end+1, subarray)
  else
    subarray.append(xs[start .. end+1])
    return genSubArray(arr, start+1, end, subarray)

maxSubarray(xs):
  subArrays = genSubArray(xs, 0, len(xs), [])

  return max (map (sum, subArrays))
\end{verbatim}

\subsubsection*{Description}
This code solves the problem by first recursively finding the subarrays of a given array. Then, it calculates the sum of each subarray and takes the max. This works because given every single possible subarray, we can brute force test all the subarrays by finding the sum and taking the highest value found.

\subsubsection*{Efficiency}
Generating the subarrays is done in $O(n^2)$ since there is a nested recursive call where both calls go over the entire array. To find the max of the subarrays is done in $O(n^2)$ as the subarray list now contains $n^2$ number of elements and the sum is mapped to each subarray. The max is then found in linear time. Therefore the overall effeciency $O(n^2)$.
