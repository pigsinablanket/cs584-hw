\documentclass[11pt]{article}
\usepackage{amsmath,amssymb,amsthm,enumitem,clrscode3e}
\usepackage[margin=1in]{geometry}

\title{\bf Proposal \\[2ex]
\rm\normalsize Due: January 30, 2020}
\date{}
\author{
  Kanyid, Bradon\\
  \texttt{bradon.kanyid@pdx.edu}
  \and
  Reimer, Daniel\\
  \texttt{daniel.reimer@pdx.edu}
}
\begin{document}
\maketitle

\section{Data Structures}
For our final project, we intend to research treaps and skip lists, and their comparison to deterministic self-balancing trees. We will attempt to determine how close to balanced they are, as well as how well they perform. In other words, we will be comparing trees that balance through randomness, like the treap and skip list algorithms to a tree that maintains a balanced tree programatically.

\section{Algorithms}
The algorithms we are planning to implement are treaps and skip lists, both probabilistic randomized algorithms. We will also implement a red-black tree as our deterministic self-balancing tree. There are deterministic ways to implement both treaps and skip lists but for the sake of the problem we are focusing on, these two algorithms will be implemented through random and probablistic means.

\section{Programming Language}
All of the algorithms will be implemented in Python, as it is the language with the least friction for our team members. It is well-known by both of us, and also has a rich library to aid with graph generation. Another benefit to using Python is that the implementation of Python for both space-complexity and time-complexity is easy to reason about, when compared to some other languages.

\section{Comparison Outline}
In order to compare these algorithms, we will first need to have a better understanding of randomized algorithms in general, as neither of us have used (knowingly) or implemented a randomized algorithm. We will then compare standard tree access methods (insert, delete, lookup), and the complexity of each. We will also experimentally test the three algorithms with random datasets and compare the results. If it is easy to demonstrate a worst-case behavior in an algorithm, we may also generate this ``adversarial'' input data, to demonstrate this.

In the end, we will present our results, to show that we have both compared and contrasted the pros and cons of each type of algorithm.

\end{document}
